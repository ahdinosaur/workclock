var Promise = require('bluebird');

var sql = require('sql');
var expect = require('test').expect;

var Edge = sql.Model.extend({
  tableName: 'edges',
  source: function () {
    return this.belongsTo(Vertex, 'sourceId');
  },
  target: function () {
    return this.belongsTo(Vertex, 'targetId');
  },
});

var Vertex = sql.Model.extend({
  tableName: 'vertexes',
  in: function () {
    return this.hasMany(Edge, 'targetId');
  },
  out: function () {
    return this.hasMany(Edge, 'sourceId');
  },
  parents: function () {
    return this.hasMany(Vertex, 'targetId').through(Edge, 'id', 'sourceId');
  },
  children: function () {
    return this.hasMany(Vertex, 'sourceId').through(Edge, 'id', 'targetId');
  },
});

describe("Vertex", function () {
  var self = this;

  before(function () {
    return Promise.all([
      // burn some Vertex's to offset the ids
      // between Vertex and Edge
      new Vertex().save().call('destroy'),
      new Vertex().save().call('destroy'),
      new Vertex().save().call('destroy'),
      new Vertex().save().call('destroy'),
      // end burn
      new Vertex().save(),
      new Vertex().save(),
      new Vertex().save(),
    ]).spread(function (a, b, c, d, n1, n2, n3) {
      self.n1 = n1;
      self.n2 = n2;
      self.n3 = n3;


      return Promise.all([
        n1.children().attach([n2]),
        n2.children().attach([n3]),
      ]);
    });
  });

  describe("out", function () {

    it("of n2 should be n2->n3 edge", function () {
      return self.n2.load(['out']).then(function (vertex) {
        var outVal = vertex.related('out');
        expect(outVal).to.have.length(1);
        var a23 = self.a23 = outVal.models[0];
        expect(a23.toJSON()).to.have.property('sourceId', self.n2.id);
        expect(a23.toJSON()).to.have.property('targetId', self.n3.id);
      });
    });
  });

  describe("in", function () {

    it("of n2 should be n1->n2 edge", function () {
      return self.n2.load(['in']).then(function (vertex) {
        var inVal = vertex.related('in');
        expect(inVal).to.have.length(1);
        var a12 = self.a12 = inVal.models[0];
        expect(a12.toJSON()).to.have.property('sourceId', self.n1.id);
        expect(a12.toJSON()).to.have.property('targetId', self.n2.id);
      });
    });
  });

  describe("children", function () {
    it("of n2 should be [n3]", function () {
      return self.n2.load(['children']).then(function (vertex) {
        var children = vertex.related('children');
        expect(children).to.have.length(1);
        expect(children.models[0].id).to.equal(self.n3.id);
      });
    });
  });

  describe("parents", function () {
    it("of n2 should be [n1]", function () {
      return self.n2.load(['parents']).then(function (vertex) {
        var parents = vertex.related('parents');
        expect(parents).to.have.length(1);
        expect(parents.models[0].id).to.equal(self.n1.id);
      });
    });
  });

  after(function () {
    return Promise.all([
      self.n1.destroy(),
      self.n2.destroy(),
      self.n3.destroy(),
      self.a12.destroy(),
      self.a23.destroy(),
    ]);
  });
});