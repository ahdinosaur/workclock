"use strict";

/* code ported from https://github.com/DrTom/digraph-demo/blob/master/app/models/arc.rb */

var Promise = require('bluebird');
var sql = require('sql');
var createError = require('create-error');
var _ = require('underscore');

var Vertex = require('./Vertex');

var bfs = function (to, from) {
  var Edges = require('./Edges');
  return function step (soFarIds, prevIds) {
    prevIds = prevIds || soFarIds;
    return new Edges().query('whereIn', to, prevIds).fetch().then(function (nextEdges) {
      // get from ids from next edges
      var nextIds = _.pluck(nextEdges.toJSON(), from)
      // remove any we have already seen
      nextIds = _.difference(nextIds, soFarIds);
      // join all the ids we have seen together
      soFarIds = _.union(soFarIds, prevIds, nextIds);
      // if we didn't see anything new
      if (nextIds.length === 0) {
        // return all edges found
        return new Edges().query('whereIn', to, soFarIds).fetch();
      } else {
        // query for more edges
        return step(soFarIds, nextIds);
      }
    });
  };
};

var NonDAGError = createError('NonDAGError');

var Edge = module.exports = sql.Model.extend({
  tableName: 'holon_arcs',
  initialize: function () {
    this.on('saving', this.preventBackLoop);
    this.on('saving', this.preventCycle);
    this.on('saving', this.preventMultiEdge);
    this.on('saving', this.preventSelfLoop);
  },
  source: function () {
    return this.belongsTo(Vertex, 'sourceId');
  },
  target: function () {
    return this.belongsTo(Vertex, 'targetId');
  },
  successors: function () {
    return bfs('sourceId', 'targetId')([this.get('targetId')]);
  },
  predecessors: function () {
    return bfs('targetId', 'sourceId')([this.get('sourceId')]);
  },
  preventBackLoop: function () {
    return this
    .query('where', 'targetId', this.get('sourceId'))
    .query('andWhere', 'sourceId', this.get('targetId'))
    .fetch()
    .then(function (result) {
      if (result !== null) {
        return Promise.reject(new Edge.Err.BackLoopError);
      }
    });
  },
  preventCycle: function () {
    return;
  },
  preventMultiEdge: function () {
    return this
    .query('where', 'targetId', this.get('targetId'))
    .query('andWhere', 'sourceId', this.get('sourceId'))
    .fetch()
    .then(function (result) {
      if (result !== null) {
        return Promise.reject(new Edge.Err.MultiEdgeError);
      }
    });
  },
  preventSelfLoop: function () {
    if (this.get('targetId') === this.get('sourceId')) {
      return Promise.reject(new Edge.Err.SelfLoopError);
    }
  },
}, {
  Err: {
    NonDAGError: NonDAGError,
    BackLoopError: createError(NonDAGError, "BackLoopError", {
      message: "back loops are not allowed.",
    }),
    CycleError: createError(NonDAGError, "CycleError", {
      message: "cycles are not allowed.",
    }),
    MultiEdgeError: createError(NonDAGError, "MultiEdgeError", {
      message: "multi-edges are not allowed.",
    }),
    SelfLoopError: createError(NonDAGError, "SelfLoopError", {
      message: "self loops are not allowed.",
    }),
  },
});
